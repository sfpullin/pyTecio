#include "DataSetWriterMPI.h"
#include "ThirdPartyHeadersBegin.h"
#include <boost/foreach.hpp>
#include <boost/static_assert.hpp>
#include <boost/unordered_map.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "FieldData.h"
#include "FileWriterInterface.h"
#include "ItemSetIterator.h"
#include "MPICommunicator.h"
#include "MPINonBlockingCommunicationCollection.h"
#include "NodeMap.h"
#include "TecioMPI.h"
#include "zoneUtil.h"
#include "ZoneWriterAbstract.h"
#include "ZoneWriterFactoryMPI.h"
using namespace tecplot::___3931; namespace tecplot { namespace teciompi { DataSetWriterMPI::DataSetWriterMPI( ___37*               ___36, ___3499                    vars, ___3499                    ___4669, ___1842 const&                maxIJKSubzoneSize, ___2088::ItemOffset_t maxFESubzoneSize, MPI_Comm                  communicator, int                       mainProcess, int                       localProcess, bool                      flushToDisk  ) : DataSetWriter(___36, vars, ___4669, maxIJKSubzoneSize, maxFESubzoneSize, flushToDisk) , m_communicator(communicator) , m_mainProcess(mainProcess) , m_localProcess(localProcess) {} DataSetWriterMPI::~DataSetWriterMPI() {} ___372 DataSetWriterMPI::writeDataSet( FileWriterInterface& szpltFile, ___1390&        szpltZoneHeaderFileLocs) { REQUIRE(szpltFile.___2039()); if (!___2335->___894()) return ___4224; ___372 ___2037 = ___4224; try { ZoneWriterFactoryMPI ___4708(___2678, *___2335, m_communicator, m_mainProcess); boost::unordered_map<___4634, boost::shared_ptr<___4707> > zoneWriterMap; std::vector<int32_t> localZoneIndices; std::vector<int32_t> partitionedZones; int32_t ___2844 = static_cast<int32_t>(m_zoneIter->___2810()); std::vector<int32_t> zoneOwners(___2844, -1); m_zoneIter->reset(); ___4634 const ___341 = m_zoneIter->baseItem(); while (___2037 && m_zoneIter->hasNext()) { ___4634 const ___902 = m_zoneIter->next(); ___4634 const fileZoneIndex = ___902 - ___341; if (!___2335->___4636(___902 + 1)) continue; if (___2335->zoneIsPartitioned(___902 + 1)) zoneOwners[fileZoneIndex] = m_mainProcess; else zoneOwners[fileZoneIndex] = ___2335->zoneGetOwnerProcess(___902 + 1); if (zoneOwners[fileZoneIndex] == m_localProcess) localZoneIndices.push_back(fileZoneIndex); else if (m_localProcess != m_mainProcess) partitionedZones.push_back(fileZoneIndex); if (___2335->zoneIsPartitioned(___902 + 1) || zoneOwners[fileZoneIndex] == m_localProcess) { std::vector<___372> ___4562; ___372 ___4497; getZoneSharing(___4562, ___4497, ___902, ___341, szpltFile.___842()); zoneWriterMap[fileZoneIndex] = ___4708.___4706(*m_varIter, ___902, m_flushingToDisk ? 0 : ___341, ___4562, ___4497); } } int32_t const numLocalZones = static_cast<int32_t>(localZoneIndices.size()); std::vector<uint64_t> localZoneSizes; BOOST_FOREACH(int32_t localZoneIndex, localZoneIndices) localZoneSizes.push_back(zoneWriterMap[localZoneIndex]->zoneFileSize(szpltFile.___2000() == ___4224)); BOOST_FOREACH(int32_t localZoneIndex, partitionedZones) (void)zoneWriterMap[localZoneIndex]->zoneFileSize(szpltFile.___2000() == ___4224); std::vector<uint64_t> zoneSizes(1); std::vector<int32_t> numZonesPerRank(1, 0); std::vector<int32_t> offsets(1, 0); if (m_localProcess == m_mainProcess) { int32_t numRanks; MPI_Comm_size(m_communicator, &numRanks); numZonesPerRank.resize(numRanks, 0);
offsets.resize(numRanks + 1, 0); BOOST_FOREACH(int32_t owner, zoneOwners) ++numZonesPerRank[owner]; for (int32_t i = 0; i < numRanks; ++i) offsets[i + 1] = offsets[i] + numZonesPerRank[i]; zoneSizes.resize(___2844); } if (localZoneSizes.empty()) localZoneSizes.resize(1); MPI_Gatherv(&localZoneSizes[0], numLocalZones, MPI_UINT64_T, &zoneSizes[0], &numZonesPerRank[0], &offsets[0], MPI_UINT64_T, m_mainProcess, m_communicator); std::vector<uint64_t> zoneFileLocs(1); std::vector<uint64_t> localZoneFileLocs(std::max(1, numLocalZones)); if (m_localProcess == m_mainProcess) { int32_t numRanks; MPI_Comm_size(m_communicator, &numRanks); zoneFileLocs.resize(___2844); std::vector<int32_t> tempNumZonesPerRank(numRanks, 0); ___1391 fileLoc = szpltFile.fileLoc(); for (int i = 0; i < ___2844; ++i) { int32_t const owner = zoneOwners[i]; int32_t const zoneOffset = offsets[owner] + tempNumZonesPerRank[owner]++; zoneFileLocs[zoneOffset] = fileLoc; fileLoc += zoneSizes[zoneOffset]; } } MPI_Scatterv(&zoneFileLocs[0], &numZonesPerRank[0], &offsets[0], MPI_UINT64_T, &localZoneFileLocs[0], numLocalZones, MPI_UINT64_T, m_mainProcess, m_communicator); boost::unordered_map<___4634, ___1391> localZoneFileLocMap; for (int i = 0; i < numLocalZones; ++i) localZoneFileLocMap[localZoneIndices[i]] = localZoneFileLocs[i]; std::vector<uint64_t> localHeaderFileLocations; localHeaderFileLocations.reserve(std::max((size_t)1, localZoneIndices.size())); std::vector<___2477> localMinMaxes; int32_t const ___2841 = m_varIter->___2810(); localMinMaxes.reserve(static_cast<size_t>(___2841) * numLocalZones); m_zoneIter->reset(); while (___2037 && m_zoneIter->hasNext()) { ___4634 const ___902 = m_zoneIter->next(); ___4634 const fileZone = ___902 - ___341; if (!___2335->___4636(___902 + 1)) continue; if (___2335->zoneIsPartitioned(___902 + 1) || zoneOwners[fileZone] == m_localProcess) { ___2037 = zoneWriterMap[fileZone]->writeZone(szpltFile, localZoneFileLocMap[fileZone]); } if (zoneOwners[fileZone] == m_localProcess) { localHeaderFileLocations.push_back(zoneWriterMap[fileZone]->getZoneHeaderFilePosition()); m_varIter->reset(); while (m_varIter->hasNext()) { ___4350 const ___4334 = m_varIter->next(); localMinMaxes.push_back(zoneWriterMap[fileZone]->varMinMax(___4334)); } } zoneWriterMap.erase(fileZone); if (szpltFile.___842() == ___843) ___2678.remove(fileZone); } if (localHeaderFileLocations.empty()) localHeaderFileLocations.resize(1); std::vector<uint64_t> rankOrderZoneHeaderFileLocs(___2844); MPI_Gatherv(&localHeaderFileLocations[0], numLocalZones, MPI_UINT64_T, &rankOrderZoneHeaderFileLocs[0], &numZonesPerRank[0], &offsets[0], MPI_UINT64_T, m_mainProcess, m_communicator); if (m_localProcess == m_mainProcess) { std::vector<int32_t> tempNumZonesPerRank(numZonesPerRank.size(), 0); for(size_t i = 0; i < zoneOwners.size(); ++i) { int32_t const owner = zoneOwners[i]; int32_t const zoneOffset = offsets[owner] + tempNumZonesPerRank[owner]++;
szpltZoneHeaderFileLocs[i] = rankOrderZoneHeaderFileLocs[zoneOffset]; } ___476(tempNumZonesPerRank == numZonesPerRank); } BOOST_STATIC_ASSERT(sizeof(___2477) == 2 * sizeof(double)); std::vector<___2477> rankOrderMinMaxes(1); std::vector<int32_t> numValuesPerRank(1); if (m_localProcess == m_mainProcess) { rankOrderMinMaxes.resize(___2844 * ___2841); numValuesPerRank.resize(numZonesPerRank.size()); for (size_t i = 0; i < numZonesPerRank.size(); ++i) { numValuesPerRank[i] = 2 * ___2841 * numZonesPerRank[i]; offsets[i] *= (2 * ___2841); } } if (localMinMaxes.empty()) localMinMaxes.resize(1); MPI_Gatherv(&localMinMaxes[0], 2 * numLocalZones * ___2841, MPI_DOUBLE, &rankOrderMinMaxes[0], &numValuesPerRank[0], &offsets[0], MPI_DOUBLE, m_mainProcess, m_communicator); if (m_localProcess == m_mainProcess) { BOOST_FOREACH(int32_t& ___2863, offsets) ___2863 /= 2; std::vector<int32_t> tempNumZonesPerRank(numZonesPerRank.size(), 0); for (size_t zone = 0; zone < zoneOwners.size(); ++zone) { int32_t const owner = zoneOwners[zone]; int32_t const zoneOffset = offsets[owner] + ___2841 * tempNumZonesPerRank[owner]++; for (int ___4334 = 0; ___4334 < ___2841; ++___4334) { ___4634 const shareZone = m_zoneVarMetadata->m_vzShareVarWithZone[___4334][zone]; ___4634 const fileShareZone = shareZone - ___341; ___476(IMPLICATION(shareZone != NOT_SHARED && fileShareZone < 0, m_flushingToDisk)); if (shareZone == NOT_SHARED || fileShareZone < 0) m_zoneVarMetadata->m_vzMinMaxes[___4334][zone] = rankOrderMinMaxes[static_cast<size_t>(zoneOffset) + ___4334]; else m_zoneVarMetadata->m_vzMinMaxes[___4334][zone] = m_zoneVarMetadata->m_vzMinMaxes[___4334][fileShareZone]; } } } } catch(std::exception const& e) { ___2037 = ___1184(e.what()); } return ___2037; } }}
